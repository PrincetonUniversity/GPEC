c-----------------------------------------------------------------------
c     calculate plasma inductance by reduced eigen function set.
c-----------------------------------------------------------------------
      WRITE(*,*)"calculate plasma inductance matrix by reduced eigen 
     $     function set by mcount=",mcount
      ALLOCATE(marking(mpert))
      ALLOCATE(flxband(mpert),kapbandmats(mpert,mpert))
      ALLOCATE(temp1(mpert,mpert))
      mcount=mpert-mexclude
      k=CEILING(mcount/2.0)
      DO i=1,mpert
         l=0
         marking=0
         flxband=0
         kapbandmats=0
         IF (i.LE.k) THEN
            marking(1:mcount)=1
         ELSE 
            IF (i.GT.(mpert-k)) THEN
            marking(mpert-mcount+1:mpert)=1
            ELSE
               marking(i-k+1:i-k+mcount)=1
            ENDIF
         ENDIF
         DO j=1,mpert
            IF (marking(j).EQ.1) THEN
               l=l+1
               flxband(j)=flxmats(l,i)
               kapbandmats(j,:)=kapmats(l,:)
            ELSE
               kapbandmats(j,j)=1
            ENDIF
         ENDDO
         ALLOCATE(ipiv(mpert))
         CALL zgetrf(mpert,mpert,kapbandmats,mpert,ipiv,infos)
         CALL zgetrs('N',mpert,1,kapbandmats,mpert,ipiv,
     $        flxband,mpert,infos)
         DEALLOCATE(ipiv)         
         reduced_indmats(i,:)=flxband(:)
      ENDDO
      reduced_indmats=2*(reduced_indmats+
     $     TRANSPOSE(CONJG(reduced_indmats)))
      temp1=reduced_indmats
      lwork=2*mpert-1
      ALLOCATE(ipiv(mpert),work(lwork),rwork(3*mpert-2))
      CALL zheev('V','U',mpert,temp1,mpert,reduced_indev,
     $     work,lwork,rwork,infos)
      DEALLOCATE(temp1,ipiv,work,rwork)
      DEALLOCATE(marking,flxband,kapbandmats)

c-----------------------------------------------------------------------
c     matching matrices for magnetic island control.
c-----------------------------------------------------------------------
      INTEGER :: cpert,ising,ipert,jpert,sstep,rstep,lstep,iqty,resnum
      REAL(r8) :: rpsi,lpsi
      COMPLEX(r8) :: rthipsi,lthipsi,rdthipsi,ldthipsi,rjump,ljump

      REAL(r8), DIMENSION(:), POINTER :: layerwd,singfac
      COMPLEX(r8), DIMENSION(:), POINTER :: sjump,thipsifac
      COMPLEX(r8), DIMENSION(:,:), POINTER :: fmat,gmat,kmat

      WRITE(*,*)"start island control matrix calculations"
      ALLOCATE(layerwd(msing),singfac(mpert))
      ALLOCATE(sjump(msing),thipsifac(mpert))
      ALLOCATE(fmat(mband+1,mpert),gmat(mband+1,mpert),
     $     kmat(2*mband+1,mpert))
      edge_flag=.TRUE.
      DO cpert=1,cmpert
         edge_mn=0
         edge_mn(cpert+cmlow-mlow)=1.0
         WRITE(*,'(1x,i2,a)')cpert+cmlow-1,
     $        "th flux response by each islands"
         edge_mn=MATMUL(tramats,edge_mn)
         CALL idcon_build(0,edge_mn)
         DO ising=1,msing
            layerwd(ising)=0.00005
            resnum=NINT(singtype(ising)%q)*nn-mlow+1
            rpsi=singtype(ising)%psifac+layerwd(ising)
            CALL spline_eval(sq,rpsi,1)
            CALL cspline_eval(fmats,rpsi,0)
            CALL cspline_eval(gmats,rpsi,0)
            CALL cspline_eval(kmats,rpsi,0)
            CALL cspline_eval(u1,rpsi,0)
            CALL cspline_eval(u2,rpsi,0)
            singfac=mfac-nn*sq%f(4)
            rthipsi=u1%f(resnum)

            fmat=0
            gmat=0
            iqty=1
            DO jpert=1,mpert
               DO ipert=jpert,MIN(mpert,jpert+mband)
                  fmat(1+ipert-jpert,jpert)=fmats%f(iqty)
                  gmat(1+ipert-jpert,jpert)=gmats%f(iqty)
                  iqty=iqty+1
               ENDDO
            ENDDO
            kmat=0
            iqty=1
            DO jpert=1,mpert
               DO ipert=MAX(1,jpert-mband),MIN(mpert,jpert+mband)
                  kmat(1+mband+ipert-jpert,jpert)=kmats%f(iqty)
                  iqty=iqty+1
               ENDDO
            ENDDO
            thipsifac=0
            thipsifac=u2%f/singfac
            CALL zgbmv('N',mpert,mpert,mband,mband,-ione,kmat,
     $           2*mband+1,u1%f,1,ione,thipsifac,1)
            CALL zpbtrs('L',mpert,mband,1,fmat,mband+1,thipsifac,
     $           mpert,infos)
            rdthipsi=thipsifac(resnum)/singfac(resnum)         
            rjump=twopi*ifac*((singtype(ising)%q-sq%f(4))/sq%f(4)*
     $           rdthipsi-singtype(ising)%q*sq%f1(4)/
     $           (sq%f(4)**2)*rthipsi)

            lpsi=singtype(ising)%psifac-layerwd(ising)
            CALL spline_eval(sq,lpsi,1)
            CALL cspline_eval(fmats,lpsi,0)
            CALL cspline_eval(gmats,lpsi,0)
            CALL cspline_eval(kmats,lpsi,0)
            CALL cspline_eval(u1,lpsi,0)
            CALL cspline_eval(u2,lpsi,0)
            singfac=mfac-nn*sq%f(4)
            lthipsi=u1%f(resnum)

            fmat=0
            gmat=0
            iqty=1
            DO jpert=1,mpert
               DO ipert=jpert,MIN(mpert,jpert+mband)
                  fmat(1+ipert-jpert,jpert)=fmats%f(iqty)
                  gmat(1+ipert-jpert,jpert)=gmats%f(iqty)
                  iqty=iqty+1
               ENDDO
            ENDDO
            kmat=0
            iqty=1
            DO jpert=1,mpert
               DO ipert=MAX(1,jpert-mband),MIN(mpert,jpert+mband)
                  kmat(1+mband+ipert-jpert,jpert)=kmats%f(iqty)
                  iqty=iqty+1
               ENDDO
            ENDDO
            thipsifac=0
            thipsifac=u2%f/singfac
            CALL zgbmv('N',mpert,mpert,mband,mband,-ione,kmat,
     $           2*mband+1,u1%f,1,ione,thipsifac,1)
            CALL zpbtrs('L',mpert,mband,1,fmat,mband+1,thipsifac,
     $           mpert,infos)
            ldthipsi=thipsifac(resnum)/singfac(resnum)         
            ljump=twopi*ifac*((singtype(ising)%q-sq%f(4))/sq%f(4)*
     $           ldthipsi-singtype(ising)%q*sq%f1(4)/
     $           (sq%f(4)**2)*lthipsi)

            sjump(ising)=rjump-ljump
            singcoupmats(ising,cpert)=sjump(ising)
            WRITE(*,*)singtype(ising)%q,sq%f(4),
     $           REAL(REAL(sjump(ising)),4),REAL(AIMAG(sjump(ising)),4)
         ENDDO
         WRITE(*,*)
      ENDDO

c-----------------------------------------------------------------------
c     subprogram 7. ipout_singresp.
c     calculate the plasma response on the each singular surface.
c     input can be given by various thetatype, but by fourier modes
c     thetatype: 0=angle,1=hamada,2=pest,3=equal_arc,4=boozer
c     rbinmn should be on the control surface.
c-----------------------------------------------------------------------
      SUBROUTINE ipout_singresp(rbinmn,lobm,rawm,thetatype)
c-----------------------------------------------------------------------
c     declaration.
c-----------------------------------------------------------------------
      INTEGER :: lobm,rawm,thetatype
      COMPLEX(r8), DIMENSION(rawm) :: rbinmn

      INTEGER :: i,ising,itheta,iqty,s
      REAL(r8) :: chi1,rfac,jac,bpfac,btfac,bfac,fac,psiin,thetai
      CHARACTER(1) :: senum

      REAL(r8), DIMENSION(mpert) :: singfac
      REAL(r8), DIMENSION(0:mthsurf) :: theta,r,z,dphi,delpsi,wgtfun
      COMPLEX(r8), DIMENSION(mpert) :: binmn,finmn,foutmn,boutmn,
     $     bpsimn,xpsimn
      COMPLEX(r8), DIMENSION(0:mthsurf) :: binfun,finfun,
     $     foutfun,boutfun,bpsifun

      REAL(r8), DIMENSION(1,2) :: w
      REAL(r8), DIMENSION(0:mthsurf,0:4) :: thetas
      COMPLEX(r8), DIMENSION(msing,mpert) :: bsingmn
      COMPLEX(r8), DIMENSION(msing,0:mthsurf) :: bsingfun

      TYPE(spline_type) :: spl 
c-----------------------------------------------------------------------
c     calculate basic functions on the control surface.
c-----------------------------------------------------------------------
      binmn(:)=rbinmn(mlow-lobm+1:mhigh-lobm+1)
      chi1=twopi*psio
      psiin=psilim
      thetatype=1
      s=thetatype  

      CALL spline_alloc(spl,mthsurf,4)
      theta=(/(itheta,itheta=0,mthsurf)/)/REAL(mthsurf,r8)
      spl%xs=theta

      CALL spline_eval(sq,psiin,1)
      singfac=mfac-nn*sq%f(4)
      DO itheta=0,mthsurf
         CALL bicube_eval(rzphi,psiin,theta(itheta),1)
         rfac=SQRT(rzphi%f(1))
         thetas(itheta,0)=theta(itheta)+rzphi%f(2)
         r(itheta)=ro+rfac*COS(twopi*thetas(itheta,0))
         z(itheta)=zo+rfac*SIN(twopi*thetas(itheta,0))
         dphi(itheta)=rzphi%f(3)
         jac=rzphi%f(4)
         w(1,1)=(1+rzphi%fy(2))*twopi**2*rfac*r(itheta)/jac
         w(1,2)=-rzphi%fy(1)*pi*r(itheta)/(rfac*jac)
         delpsi(itheta)=SQRT(w(1,1)**2+w(1,2)**2)
         wgtfun(itheta)=1.0/(jac*delpsi(itheta))

         bpfac=psio*delpsi(itheta)/r(itheta)
         btfac=sq%f(1)/(twopi*r(itheta))
         bfac=SQRT(bpfac*bpfac+btfac*btfac)
         fac=r(itheta)**power_r/(bpfac**power_bp*bfac**power_b)
         spl%fs(itheta,1)=fac                        
         spl%fs(itheta,2)=fac/r(itheta)**2
         spl%fs(itheta,3)=fac*bpfac
         spl%fs(itheta,4)=fac*bpfac**2
      ENDDO
      CALL spline_fit(spl,"periodic")
      CALL spline_int(spl)
      DO iqty=1,4
         thetas(:,iqty)=spl%fsi(:,iqty)/spl%fsi(mthsurf,iqty)
      ENDDO
      CALL spline_dealloc(spl)
      CALL iscdftb(mfac,mpert,binfun,mthsurf,binmn)
c-----------------------------------------------------------------------
c     get the complex hamada-weighted function.
c-----------------------------------------------------------------------      
      DO itheta=0,mthsurf
         finfun(itheta)=0
         DO i=1,mpert
            finfun(itheta)=finfun(itheta)+
     $           binmn(i)*EXP(ifac*twopi*(i+mlow-1)*thetas(itheta,s))
         ENDDO
      ENDDO
      finfun(:)=finfun(:)*EXP(-ifac*nn*dphi(:))/SQRT(wgtfun(:))
c-----------------------------------------------------------------------
c     calculate response on the control surface in hamada space.
c-----------------------------------------------------------------------
      CALL iscdftf(mfac,mpert,finfun,mthsurf,finmn)      
      foutmn=MATMUL(permeabilitymats,finmn)
      CALL iscdftb(mfac,mpert,foutfun,mthsurf,foutmn)
c-----------------------------------------------------------------------
c     return back to the original theta function on the control surface.
c-----------------------------------------------------------------------
      boutfun(:)=foutfun(:)*EXP(ifac*nn*dphi(:))*SQRT(wgtfun(:))
      CALL iscdftf(mfac,mpert,boutfun,mthsurf,boutmn)
      DO itheta=0,mthsurf
         boutfun(itheta)=0
         thetai=issect(mthsurf,theta(:),thetas(:,s),theta(itheta))
         DO i=1,mpert
            boutfun(itheta)=boutfun(itheta)+
     $           boutmn(i)*EXP(ifac*twopi*(i+mlow-1)*thetai)
         ENDDO
      ENDDO
      CALL iscdftf(mfac,mpert,boutfun,mthsurf,boutmn)
c-----------------------------------------------------------------------
c     write the boundary condition and solve inner solutions.
c     check the normalization, because of delpsi factor.
c-----------------------------------------------------------------------
      bpsifun(:)=foutfun(:)*SQRT(wgtfun(:))*delpsi(:)
      CALL iscdftf(mfac,mpert,bpsifun,mthsurf,bpsimn)
      xpsimn=jac/(chi1*singfac*twopi*ifac)*bpsimn
      edge_flag=.TRUE.
      CALL idcon_build(0,xpsimn)
c-----------------------------------------------------------------------
c     calculate basic functions on the singular surface.
c-----------------------------------------------------------------------
      DO ising=1,msing
         psiin=singtype(ising)%psifac

         CALL spline_alloc(spl,mthsurf,4)
         spl%xs=theta

         CALL spline_eval(sq,psiin,1)
         singfac=mfac-nn*sq%f(4)
         DO itheta=0,mthsurf
            CALL bicube_eval(rzphi,psiin,theta(itheta),1)
            rfac=SQRT(rzphi%f(1))
            thetas(itheta,0)=theta(itheta)+rzphi%f(2)
            r(itheta)=ro+rfac*COS(twopi*thetas(itheta,0))
            z(itheta)=zo+rfac*SIN(twopi*thetas(itheta,0))
            dphi(itheta)=rzphi%f(3)
            jac=rzphi%f(4)
            w(1,1)=(1+rzphi%fy(2))*twopi**2*rfac*r(itheta)/jac
            w(1,2)=-rzphi%fy(1)*pi*r(itheta)/(rfac*jac)
            delpsi(itheta)=SQRT(w(1,1)**2+w(1,2)**2)
            wgtfun(itheta)=1.0/(jac*delpsi(itheta))

            bpfac=psio*delpsi(itheta)/r(itheta)
            btfac=sq%f(1)/(twopi*r(itheta))
            bfac=SQRT(bpfac*bpfac+btfac*btfac)
            fac=r(itheta)**power_r/(bpfac**power_bp*bfac**power_b)
            spl%fs(itheta,1)=fac                        
            spl%fs(itheta,2)=fac/r(itheta)**2
            spl%fs(itheta,3)=fac*bpfac
            spl%fs(itheta,4)=fac*bpfac**2
         ENDDO
         CALL spline_fit(spl,"periodic")
         CALL spline_int(spl)
         DO iqty=1,4
            thetas(:,iqty)=spl%fsi(:,iqty)/spl%fsi(mthsurf,iqty)
         ENDDO
         CALL spline_dealloc(spl)     
c-----------------------------------------------------------------------
c     read inner solution and return back to the original coordinate.
c-----------------------------------------------------------------------
         CALL cspline_eval(u1,psiin,0)
         bsingmn(ising,:)=(chi1*singfac*twopi*ifac*u1%f)/jac
         CALL iscdftb(mfac,mpert,bsingfun(ising,:),mthsurf,
     $        bsingmn(ising,:))
         bsingfun(ising,:)=bsingfun(ising,:)/delpsi(:)*
     $        EXP(ifac*nn*dphi(:))   
         CALL iscdftf(mfac,mpert,bsingfun(ising,:),mthsurf,
     $        bsingmn(ising,:))
         DO itheta=0,mthsurf
            bsingfun(ising,itheta)=0
            thetai=issect(mthsurf,theta(:),thetas(:,s),theta(itheta))
            DO i=1,mpert
               bsingfun(ising,itheta)=bsingfun(ising,itheta)+
     $              bsingmn(ising,i)*EXP(ifac*twopi*(i+mlow-1)*thetai)
            ENDDO
         ENDDO
         CALL iscdftf(mfac,mpert,bsingfun(ising,:),mthsurf,
     $        bsingmn(ising,:))
      ENDDO
c-----------------------------------------------------------------------
c     write functions.
c-----------------------------------------------------------------------
      CALL ascii_open(out_unit,"ipout_singresp_mode.out","UNKNOWN")
      WRITE(out_unit,*)"IPOUT_SINGULAR RESPONSE: MODES"
      WRITE(out_unit,*)"FROM:"
      WRITE(out_unit,'(2x,a2,f5.2,a18)')"q=",qlim,"(control surface)"
      WRITE(out_unit,'(2x,a3,2(2x,a12))')"m","real","imaginary"
      DO i=1,mpert
         WRITE(out_unit,'(2x,I3,2(2x,es12.3))')mfac(i),
     $        REAL(binmn(i)),AIMAG(binmn(i))
      ENDDO

      WRITE(out_unit,*)"TO:"
      WRITE(out_unit,'(2x,a2,f6.3,a18)')"q=",qlim,"(control surface)"
      DO i=1,mpert
         WRITE(out_unit,'(2x,I3,2(2x,es12.3))')mfac(i),
     $        REAL(boutmn(i)),AIMAG(boutmn(i))
      ENDDO

      DO ising=1,msing
         WRITE(out_unit,'(2x,a2,f6.3)')"q=",singtype(ising)%q
         DO i=1,mpert
            WRITE(out_unit,'(2x,I3,2(2x,es12.3))')mfac(i),
     $           REAL(bsingmn(ising,i)),AIMAG(bsingmn(ising,i))
         ENDDO
      ENDDO
      CALL ascii_close(out_unit)

      CALL ascii_open(out_unit,"ipout_singresp_func.out","UNKNOWN")
      WRITE(out_unit,*)"IPOUT_SINGULAR RESPONSE: FUNCTIONS"
      WRITE(out_unit,*)"FROM:"
      WRITE(out_unit,'(2x,a2,f6.3,a18)')"q=",qlim,"(control surface)"
      WRITE(out_unit,'(3(2x,a12))')"theta","real","imaginary"
      DO itheta=0,mthsurf
         WRITE(out_unit,'(3(2x,es12.3))')theta(itheta),
     $        REAL(binfun(itheta)),AIMAG(binfun(itheta))
      ENDDO

      WRITE(out_unit,*)"TO:"
      WRITE(out_unit,'(2x,a2,f5.2,a18)')"q=",qlim,"(control surface)"
      WRITE(out_unit,'(3(2x,a12))')"theta","real","imaginary"
      DO itheta=0,mthsurf
         WRITE(out_unit,'(3(2x,es12.3))')theta(itheta),
     $        REAL(boutfun(itheta)),AIMAG(boutfun(itheta))
      ENDDO

      DO ising=1,msing
         WRITE(out_unit,'(2x,a2,f6.3)')"q=",singtype(ising)%q
         DO itheta=0,mthsurf
            WRITE(out_unit,'(3(2x,es12.3))')theta(itheta),
     $        REAL(bsingfun(ising,itheta)),
     $           AIMAG(bsingfun(ising,itheta))
         ENDDO
      ENDDO
      CALL ascii_close(out_unit)
c-----------------------------------------------------------------------
c     terminate.
c-----------------------------------------------------------------------
      RETURN
      END SUBROUTINE ipout_singresp
c-----------------------------------------------------------------------
c     subprogram 8. ipout_modecoup.
c     obtain mode coupling between singular surfaces and control surface. 
c-----------------------------------------------------------------------
      SUBROUTINE ipout_modecoup(thetatype)
c-----------------------------------------------------------------------
c     declaration.
c-----------------------------------------------------------------------
      INTEGER, INTENT(IN) :: thetatype

      INTEGER :: i,ipert,ising,itheta,iqty,s
      REAL(r8) :: chi1,rfac,jac,bpfac,btfac,bfac,fac,psiin,thetai
      CHARACTER(1) :: senum

      REAL(r8), DIMENSION(mpert) :: singfac
      REAL(r8), DIMENSION(0:mthsurf) :: theta,r,z,dphi,delpsi,wgtfun
      COMPLEX(r8), DIMENSION(mpert) :: binmn,finmn,foutmn,boutmn,
     $     bpsimn,xpsimn
      COMPLEX(r8), DIMENSION(0:mthsurf) :: binfun,finfun,
     $     foutfun,boutfun,bpsifun

      REAL(r8), DIMENSION(1,2) :: w
      REAL(r8), DIMENSION(0:mthsurf,0:4) :: thetas
      COMPLEX(r8), DIMENSION(msing,mpert) :: bsingmn
      COMPLEX(r8), DIMENSION(msing,0:mthsurf) :: bsingfun

      COMPLEX(r8), DIMENSION(msing+1,mpert,mpert) :: modecoupmats

      TYPE(spline_type) :: spl 
c-----------------------------------------------------------------------
c     calculate basic functions on the control surface.
c-----------------------------------------------------------------------
      chi1=twopi*psio
      s=thetatype
      theta=(/(itheta,itheta=0,mthsurf)/)/REAL(mthsurf,r8)
c-----------------------------------------------------------------------
c     get the complex hamada-weighted function.
c-----------------------------------------------------------------------
      DO ipert=1,mpert
         psiin=psilim

         CALL spline_alloc(spl,mthsurf,4)
         spl%xs=theta

         CALL spline_eval(sq,psiin,1)
         singfac=mfac-nn*sq%f(4)
         DO itheta=0,mthsurf
            CALL bicube_eval(rzphi,psiin,theta(itheta),1)
            rfac=SQRT(rzphi%f(1))
            thetas(itheta,0)=theta(itheta)+rzphi%f(2)
            r(itheta)=ro+rfac*COS(twopi*thetas(itheta,0))
            z(itheta)=zo+rfac*SIN(twopi*thetas(itheta,0))
            dphi(itheta)=rzphi%f(3)
            jac=rzphi%f(4)
            w(1,1)=(1+rzphi%fy(2))*twopi**2*rfac*r(itheta)/jac
            w(1,2)=-rzphi%fy(1)*pi*r(itheta)/(rfac*jac)
            delpsi(itheta)=SQRT(w(1,1)**2+w(1,2)**2)
            wgtfun(itheta)=1.0/(jac*delpsi(itheta))

            bpfac=psio*delpsi(itheta)/r(itheta)
            btfac=sq%f(1)/(twopi*r(itheta))
            bfac=SQRT(bpfac*bpfac+btfac*btfac)
            fac=r(itheta)**power_r/(bpfac**power_bp*bfac**power_b)
            spl%fs(itheta,1)=fac                        
            spl%fs(itheta,2)=fac/r(itheta)**2
            spl%fs(itheta,3)=fac*bpfac
            spl%fs(itheta,4)=fac*bpfac**2
         ENDDO
         CALL spline_fit(spl,"periodic")
         CALL spline_int(spl)
         DO iqty=1,4
            thetas(:,iqty)=spl%fsi(:,iqty)/spl%fsi(mthsurf,iqty)
         ENDDO
         CALL spline_dealloc(spl)

         binmn=0
         WRITE(*,*)ipert,"th mode coupling coefficient"
         binmn(ipert)=1.0
         CALL iscdftb(mfac,mpert,binfun,mthsurf,binmn)     
         DO itheta=0,mthsurf
            finfun(itheta)=0
            DO i=1,mpert
               finfun(itheta)=finfun(itheta)+
     $              binmn(i)*EXP(ifac*twopi*(i+mlow-1)*thetas(itheta,s))
            ENDDO
         ENDDO
         finfun(:)=finfun(:)*EXP(-ifac*nn*dphi(:))/SQRT(wgtfun(:))
c-----------------------------------------------------------------------
c     calculate response on the control surface in hamada space.
c-----------------------------------------------------------------------
         CALL iscdftf(mfac,mpert,finfun,mthsurf,finmn)      
         foutmn=MATMUL(permeabilitymats,finmn)
         CALL iscdftb(mfac,mpert,foutfun,mthsurf,foutmn)
c-----------------------------------------------------------------------
c     return back to the original theta function on the control surface.
c-----------------------------------------------------------------------
         boutfun(:)=foutfun(:)*EXP(ifac*nn*dphi(:))*SQRT(wgtfun(:))
         CALL iscdftf(mfac,mpert,boutfun,mthsurf,boutmn)
         DO itheta=0,mthsurf
            boutfun(itheta)=0
            thetai=issect(mthsurf,theta(:),thetas(:,s),theta(itheta))
            DO i=1,mpert
               boutfun(itheta)=boutfun(itheta)+
     $              boutmn(i)*EXP(ifac*twopi*(i+mlow-1)*thetai)
            ENDDO
         ENDDO
         CALL iscdftf(mfac,mpert,boutfun,mthsurf,boutmn)
c-----------------------------------------------------------------------
c     write the boundary condition and solve inner solutions.
c     check the normalization, because of delpsi factor.
c-----------------------------------------------------------------------
         bpsifun(:)=foutfun(:)*SQRT(wgtfun(:))*delpsi(:)
         CALL iscdftf(mfac,mpert,bpsifun,mthsurf,bpsimn)
         xpsimn=jac/(chi1*singfac*twopi*ifac)*bpsimn
         edge_flag=.TRUE.
         CALL idcon_build(0,xpsimn)
c-----------------------------------------------------------------------
c     calculate basic functions on the singular surface.
c-----------------------------------------------------------------------
         DO ising=1,msing
            psiin=singtype(ising)%psifac

            CALL spline_alloc(spl,mthsurf,4)
            spl%xs=theta

            CALL spline_eval(sq,psiin,1)
            singfac=mfac-nn*sq%f(4)
            DO itheta=0,mthsurf
               CALL bicube_eval(rzphi,psiin,theta(itheta),1)
               rfac=SQRT(rzphi%f(1))
               thetas(itheta,0)=theta(itheta)+rzphi%f(2)
               r(itheta)=ro+rfac*COS(twopi*thetas(itheta,0))
               z(itheta)=zo+rfac*SIN(twopi*thetas(itheta,0))
               dphi(itheta)=rzphi%f(3)
               jac=rzphi%f(4)
               w(1,1)=(1+rzphi%fy(2))*twopi**2*rfac*r(itheta)/jac
               w(1,2)=-rzphi%fy(1)*pi*r(itheta)/(rfac*jac)
               delpsi(itheta)=SQRT(w(1,1)**2+w(1,2)**2)
               wgtfun(itheta)=1.0/(jac*delpsi(itheta))

               bpfac=psio*delpsi(itheta)/r(itheta)
               btfac=sq%f(1)/(twopi*r(itheta))
               bfac=SQRT(bpfac*bpfac+btfac*btfac)
               fac=r(itheta)**power_r/(bpfac**power_bp*bfac**power_b)
               spl%fs(itheta,1)=fac                        
               spl%fs(itheta,2)=fac/r(itheta)**2
               spl%fs(itheta,3)=fac*bpfac
               spl%fs(itheta,4)=fac*bpfac**2
            ENDDO
            CALL spline_fit(spl,"periodic")
            CALL spline_int(spl)
            DO iqty=1,4
               thetas(:,iqty)=spl%fsi(:,iqty)/spl%fsi(mthsurf,iqty)
            ENDDO
            CALL spline_dealloc(spl)     
c-----------------------------------------------------------------------
c     read inner solution and return back to the original coordinate.
c-----------------------------------------------------------------------
            CALL cspline_eval(u1,psiin,0)
            bsingmn(ising,:)=(chi1*singfac*twopi*ifac*u1%f)/jac
            CALL iscdftb(mfac,mpert,bsingfun(ising,:),mthsurf,
     $           bsingmn(ising,:))
            bsingfun(ising,:)=bsingfun(ising,:)/delpsi(:)*
     $           EXP(ifac*nn*dphi(:))   
            CALL iscdftf(mfac,mpert,bsingfun(ising,:),mthsurf,
     $           bsingmn(ising,:))
            DO itheta=0,mthsurf
               bsingfun(ising,itheta)=0
               thetai=issect(mthsurf,theta(:),thetas(:,s),theta(itheta))
               DO i=1,mpert
                  bsingfun(ising,itheta)=bsingfun(ising,itheta)+
     $                 bsingmn(ising,i)*
     $                 EXP(ifac*twopi*(i+mlow-1)*thetai)
               ENDDO
            ENDDO
            CALL iscdftf(mfac,mpert,bsingfun(ising,:),mthsurf,
     $           bsingmn(ising,:))
c-----------------------------------------------------------------------
c     mode coupling on the singular surface.
c-----------------------------------------------------------------------
            modecoupmats(ising,:,ipert)=bsingmn(ising,:)            
         ENDDO
c-----------------------------------------------------------------------
c     mode coupling on the control surface.
c-----------------------------------------------------------------------
         modecoupmats(msing+1,:,ipert)=boutmn(:)
      ENDDO
c-----------------------------------------------------------------------
c     write results.
c-----------------------------------------------------------------------      
      CALL ascii_open(out_unit,"ipout_modecoup.out","UNKNOWN")
      WRITE(out_unit,*)"IPOUT_MODE COUPLINGS: "

      DO ising=1,msing+1
         IF (ising .LE. msing) THEN
            WRITE(out_unit,'(2x,a2,f6.3)')"q=",singtype(ising)%q 
         ELSE
            WRITE(out_unit,'(2x,a2,f6.3,a18)')
     $           "q=",qlim,"(control surface)"       
         ENDIF
         WRITE(out_unit,'(2(2x,a3),2(2x,a12))')"m","m'",
     $        "real","imaginary"
         DO i=1,mpert
            DO ipert=1,mpert
               WRITE(out_unit,'(2(2x,I3),2(2x,es12.3))')mfac(i),
     $              mfac(ipert),REAL(modecoupmats(ising,i,ipert)),
     $              AIMAG(modecoupmats(ising,i,ipert))
            ENDDO
         ENDDO
      ENDDO   
      CALL ascii_close(out_unit)
c-----------------------------------------------------------------------
c     terminate.
c-----------------------------------------------------------------------
      RETURN
      END SUBROUTINE ipout_modecoup

c-----------------------------------------------------------------------
c     subprogram 9. ipout_jumpcoup_old.
c     obtain mode coupling between magnetic jumps on the singular
c     surfaces and fourier modes on the control surface
c     in hamada coordinate system.
c-----------------------------------------------------------------------
      SUBROUTINE ipout_jumpcoup_old(eps,rsing)
c-----------------------------------------------------------------------
c     declaration.
c-----------------------------------------------------------------------
      INTEGER :: rsing
      REAL(r8), INTENT(IN) :: eps

      INTEGER :: ii,i,ising,ipert,jpert,resnum,iqty,infos,itheta
      REAL(r8) :: rpsi,lpsi
      REAL(r8) :: chi1,rfac,jac,psiin,angle
      COMPLEX(r8) :: rxipsi,lxipsi,rdxipsi,ldxipsi,rjump,ljump

      REAL(r8), DIMENSION(mpert) :: singfacedge,singfac
      REAL(r8), DIMENSION(0:mthsurf) :: theta,r,z,dphi,delpsi,wgtfun
      COMPLEX(r8), DIMENSION(rsing) :: sjump
      COMPLEX(r8), DIMENSION(mpert) :: xipsifac,binmn,
     $     boutmn,bpsimn,xpsimn
      COMPLEX(r8), DIMENSION(0:mthsurf) :: binfun,boutfun,bpsifun

      REAL(r8), DIMENSION(1,2) :: w
      COMPLEX(r8), DIMENSION(mband+1,mpert) :: fmat,gmat
      COMPLEX(r8), DIMENSION(2*mband+1,mpert) :: kmat
      COMPLEX(r8), DIMENSION(rsing,mpert) :: jumpcoupmats1
      COMPLEX(r8), DIMENSION(rsing,mpert) :: jumpcoupmats2

      psiin=psilim
      chi1=twopi*psio
      theta=(/(itheta,itheta=0,mthsurf)/)/REAL(mthsurf,r8)
      CALL spline_eval(sq,psiin,1)
      singfacedge=mfac-nn*sq%f(4)
      DO itheta=0,mthsurf
         CALL bicube_eval(rzphi,psiin,theta(itheta),1)
         rfac=SQRT(rzphi%f(1))
         angle=theta(itheta)+rzphi%f(2)
         r(itheta)=ro+rfac*COS(twopi*angle)
         z(itheta)=zo+rfac*SIN(twopi*angle)
         dphi(itheta)=rzphi%f(3)
         jac=rzphi%f(4)
         w(1,1)=(1+rzphi%fy(2))*twopi**2*rfac*r(itheta)/jac
         w(1,2)=-rzphi%fy(1)*pi*r(itheta)/(rfac*jac)
         delpsi(itheta)=SQRT(w(1,1)**2+w(1,2)**2)
         wgtfun(itheta)=1.0/(jac*delpsi(itheta))
      ENDDO

      DO ii=1,2

         DO i=1,mpert
            IF (ii .EQ.1) THEN
               binmn=0
               WRITE(*,*)i,"th mode coupling coefficient"
               binmn(i)=1.0
               CALL iscdftb(mfac,mpert,binfun,mthsurf,binmn)
               bpsifun(:)=binfun(:)*delpsi(:)
            ELSE
               binmn=0
               WRITE(*,*)i,"th mode coupling coefficient"
               binmn(i)=1.0
               CALL iscdftb(mfac,mpert,binfun,mthsurf,binmn)
               binfun(:)=binfun(:)/SQRT(wgtfun(:))
               CALL iscdftf(mfac,mpert,binfun,mthsurf,binmn)
               boutmn=MATMUL(permeabilitymats,binmn)
               CALL iscdftb(mfac,mpert,boutfun,mthsurf,boutmn)
               boutfun(:)=boutfun(:)*SQRT(wgtfun(:))
               CALL iscdftf(mfac,mpert,boutfun,mthsurf,boutmn)
               bpsifun(:)=boutfun(:)*delpsi(:)
            ENDIF
               
            CALL iscdftf(mfac,mpert,bpsifun,mthsurf,bpsimn)
            xpsimn=jac/(chi1*singfacedge*twopi*ifac)*bpsimn
            edge_flag=.TRUE.
            CALL idcon_build(0,xpsimn)               
            DO ising=1,rsing
               resnum=NINT(singtype(ising)%q)*nn-mlow+1
               rpsi=singtype(ising)%psifac+eps
               CALL spline_eval(sq,rpsi,1)
               CALL cspline_eval(fmats,rpsi,0)
               CALL cspline_eval(gmats,rpsi,0)
               CALL cspline_eval(kmats,rpsi,0)
               CALL cspline_eval(u1,rpsi,0)
               CALL cspline_eval(u2,rpsi,0)
               singfac=mfac-nn*sq%f(4)
               rxipsi=u1%f(resnum)

               fmat=0
               gmat=0
               iqty=1
               DO jpert=1,mpert
                  DO ipert=jpert,MIN(mpert,jpert+mband)
                     fmat(1+ipert-jpert,jpert)=fmats%f(iqty)
                     gmat(1+ipert-jpert,jpert)=gmats%f(iqty)
                     iqty=iqty+1
                  ENDDO
               ENDDO
               kmat=0
               iqty=1
               DO jpert=1,mpert
                  DO ipert=MAX(1,jpert-mband),MIN(mpert,jpert+mband)
                     kmat(1+mband+ipert-jpert,jpert)=kmats%f(iqty)
                     iqty=iqty+1
                  ENDDO
               ENDDO
               xipsifac=0
               xipsifac=u2%f/singfac
               CALL zgbmv('N',mpert,mpert,mband,mband,-ione,kmat,
     $              2*mband+1,u1%f,1,ione,xipsifac,1)
               CALL zpbtrs('L',mpert,mband,1,fmat,mband+1,xipsifac,
     $           mpert,infos)
               rdxipsi=xipsifac(resnum)/singfac(resnum)         
               rjump=twopi*ifac*((singtype(ising)%q-sq%f(4))/sq%f(4)*
     $              rdxipsi-singtype(ising)%q*sq%f1(4)/
     $              (sq%f(4)**2)*rxipsi)

               lpsi=singtype(ising)%psifac-eps
               CALL spline_eval(sq,lpsi,1)
               CALL cspline_eval(fmats,lpsi,0)
               CALL cspline_eval(gmats,lpsi,0)
               CALL cspline_eval(kmats,lpsi,0)
               CALL cspline_eval(u1,lpsi,0)
               CALL cspline_eval(u2,lpsi,0)
               singfac=mfac-nn*sq%f(4)
               lxipsi=u1%f(resnum)

               fmat=0
               gmat=0
               iqty=1
               DO jpert=1,mpert
                  DO ipert=jpert,MIN(mpert,jpert+mband)
                     fmat(1+ipert-jpert,jpert)=fmats%f(iqty)
                     gmat(1+ipert-jpert,jpert)=gmats%f(iqty)
                     iqty=iqty+1
                  ENDDO
               ENDDO
               kmat=0
               iqty=1
               DO jpert=1,mpert
                  DO ipert=MAX(1,jpert-mband),MIN(mpert,jpert+mband)
                     kmat(1+mband+ipert-jpert,jpert)=kmats%f(iqty)
                     iqty=iqty+1
                  ENDDO
               ENDDO
               xipsifac=0
               xipsifac=u2%f/singfac
               CALL zgbmv('N',mpert,mpert,mband,mband,-ione,kmat,
     $              2*mband+1,u1%f,1,ione,xipsifac,1)
               CALL zpbtrs('L',mpert,mband,1,fmat,mband+1,xipsifac,
     $              mpert,infos)
               ldxipsi=xipsifac(resnum)/singfac(resnum)         
               ljump=twopi*ifac*((singtype(ising)%q-sq%f(4))/sq%f(4)*
     $              ldxipsi-singtype(ising)%q*sq%f1(4)/
     $              (sq%f(4)**2)*lxipsi)

               sjump(ising)=rjump-ljump
               IF (ii.EQ.1) THEN
                  jumpcoupmats1(ising,i)=sjump(ising)
               ELSE
                  jumpcoupmats2(ising,i)=sjump(ising)
               ENDIF
            ENDDO
         ENDDO
      ENDDO
c-----------------------------------------------------------------------
c     write results.
c-----------------------------------------------------------------------      
      CALL ascii_open(out_unit,"ipout_jumpcoup.out","UNKNOWN")
      WRITE(out_unit,*)"IPOUT_JUMP COUPLINGS: "
      WRITE(out_unit,*)"epsilon: ",eps

      DO ii=1,2
         IF (ii.EQ.1) THEN
            WRITE(out_unit,*)"PLASMA ON THE SURFACE --- PLASMA"
         ELSE
            WRITE(out_unit,*)"VACUUM ON THE SURFACE --- PLASMA"
         ENDIF
         DO ising=1,rsing
            WRITE(out_unit,'(2x,a2,f6.3)')"q=",singtype(ising)%q 
            WRITE(out_unit,'(2x,a3,2(2x,a12))')"m",
     $           "real","imaginary"
            IF (ii.EQ.1) THEN            
               DO ipert=1,mpert
                  WRITE(out_unit,'(2x,I3,2(2x,es12.3))')mfac(ipert),
     $                 REAL(jumpcoupmats1(ising,ipert)),
     $                 AIMAG(jumpcoupmats1(ising,ipert))
               ENDDO
            ELSE
               DO ipert=1,mpert
                  WRITE(out_unit,'(2x,I3,2(2x,es12.3))')mfac(ipert),
     $                 REAL(jumpcoupmats2(ising,ipert)),
     $                 AIMAG(jumpcoupmats2(ising,ipert))
               ENDDO               
            ENDIF
         ENDDO
      ENDDO
      CALL ascii_close(out_unit)
c-----------------------------------------------------------------------
c     terminate.
c-----------------------------------------------------------------------
      RETURN
      END SUBROUTINE ipout_jumpcoup_old
c-----------------------------------------------------------------------
c     subprogram 10. ipout_coord.
c     diagnose coordinate system. 
c-----------------------------------------------------------------------
      SUBROUTINE ipout_coord(psi)
c-----------------------------------------------------------------------
c     declaration.
c-----------------------------------------------------------------------
      REAL(r8), INTENT(IN) :: psi
      
      INTEGER :: i,itheta
      REAL(r8) :: r,z,rfac,angle,jac,delpsi
      REAL(r8), DIMENSION(mthsurf) :: dphi,wgtfun
      REAL(r8), DIMENSION(1,2) :: w

      CALL ascii_open(out_unit,"ipout_coord.out","UNKNOWN")
      WRITE(out_unit,*)"IPOUT_COORD: check coordinate system"
      WRITE(out_unit,'(6(2x,a12))')"theta","r","z","angle","dphi",
     $     "wgtfun"
      DO itheta=0,mthsurf
         CALL bicube_eval(rzphi,psi,itheta/REAL(mthsurf,r8),1)
         rfac=SQRT(rzphi%f(1))
         angle=twopi*(itheta/REAL(mthsurf,r8)+rzphi%f(2))
         r=ro+rfac*COS(angle)
         z=zo+rfac*SIN(angle)
         dphi(itheta)=rzphi%f(3)
         jac=rzphi%f(4)
         w(1,1)=(1+rzphi%fy(2))*twopi**2*rfac*r/jac
         w(1,2)=-rzphi%fy(1)*pi*r/(rfac*jac)
         delpsi=SQRT(w(1,1)**2+w(1,2)**2)
         wgtfun(itheta)=1.0/(jac*delpsi)
         WRITE(out_unit,'(6(2x,es12.3))')itheta/REAL(mthsurf),
     $        r,z,angle,dphi(itheta),wgtfun(itheta)

      ENDDO
      CALL ascii_close(out_unit)
c-----------------------------------------------------------------------
c     terminate.
c-----------------------------------------------------------------------
      RETURN
      END SUBROUTINE ipout_coord

c-----------------------------------------------------------------------
c     subprogram 3. ipeq_ortho.
c     calculate orthogonal components of the perturbed quantities.
c-----------------------------------------------------------------------
      SUBROUTINE ipeq_ortho(psi)
c-----------------------------------------------------------------------
c     declaration.
c-----------------------------------------------------------------------
      REAL(r8) ,INTENT(IN) :: psi
 
      INTEGER :: ipert,itheta,iqty
      REAL(r8) :: rfac,angle,bpfac,btfac,bfac,fac,jac,delpsi
      COMPLEX(r8) :: expfac,expfac0,expfac1,phase 
      REAL(r8), DIMENSION(2,2) :: w
      REAL(r8), DIMENSION(:), POINTER :: theta,r,z,dphi
      REAL(r8), DIMENSION(:,:), POINTER :: thetas
      REAL(r8), DIMENSION(:,:,:), POINTER :: project
      COMPLEX(r8), DIMENSION(:,:), POINTER :: xivec0, bvec0

      TYPE(spline_type) :: spl 
c-----------------------------------------------------------------------
c     preliminary computations for transformation
c-----------------------------------------------------------------------
      ALLOCATE(r(0:mthsurf),z(0:mthsurf),
     $     theta(0:mthsurf),dphi(0:mthsurf),
     $     thetas(0:mthsurf,4),project(3,3,0:mthsurf))
      ALLOCATE(xivec0(0:mthsurf,3),bvec0(0:mthsurf,3))
      CALL spline_alloc(spl,mthsurf,4)
      theta=(/(itheta,itheta=0,mthsurf)/)/REAL(mthsurf,r8)
      spl%xs=theta
c-----------------------------------------------------------------------
c     compute geometric factors.
c-----------------------------------------------------------------------
      CALL spline_eval(sq,psi,1)
      DO itheta=0,mthsurf
         CALL bicube_eval(rzphi,psi,theta(itheta),1)
         rfac=SQRT(rzphi%f(1))
         angle=twopi*(theta(itheta)+rzphi%f(2))
         r(itheta)=ro+rfac*COS(angle)
         z(itheta)=zo+rfac*SIN(angle)
         dphi(itheta)=rzphi%f(3)
         jac=rzphi%f(4)
c-----------------------------------------------------------------------
c     compute covariant basis vectors.
c-----------------------------------------------------------------------
         w(1,1)=(1+rzphi%fy(2))*twopi**2*rfac*r(itheta)/jac
         w(1,2)=-rzphi%fy(1)*pi*r(itheta)/(rfac*jac)
         w(2,1)=-rzphi%fx(2)*twopi**2*r(itheta)*rfac/jac
         w(2,2)=rzphi%fx(1)*pi*r(itheta)/(rfac*jac)
c-----------------------------------------------------------------------
c     compute project.
c-----------------------------------------------------------------------
         delpsi=SQRT(w(1,1)**2+w(1,2)**2)
         project(1,1,itheta)=1/delpsi
         project(2,1,itheta)
     $        =-(w(1,1)*w(2,1)+w(1,2)*w(2,2))/
     $        (twopi*r(itheta)*delpsi)*jac
         project(2,2,itheta)=delpsi/(twopi*r(itheta))*jac
         project(3,1,itheta)=rzphi%fx(3)*r(itheta)
         project(3,2,itheta)=rzphi%fy(3)*r(itheta)
         project(3,3,itheta)=twopi*r(itheta)
c-----------------------------------------------------------------------
c     compute alternative theta coordinates.
c-----------------------------------------------------------------------
         bpfac=psio*delpsi/r(itheta)
         btfac=sq%f(1)/(twopi*r(itheta))
         bfac=SQRT(bpfac*bpfac+btfac*btfac)
         fac=r(itheta)**power_r/(bpfac**power_bp*bfac**power_b)
         spl%fs(itheta,1)=fac
         spl%fs(itheta,2)=fac/r(itheta)**2
         spl%fs(itheta,3)=fac*bpfac
         spl%fs(itheta,4)=fac*bpfac**2
      ENDDO
c-----------------------------------------------------------------------
c     compute alternative poloidal coordinates.
c-----------------------------------------------------------------------
      CALL spline_fit(spl,"periodic")
      CALL spline_int(spl)
      DO iqty=1,4
         thetas(:,iqty)=spl%fsi(:,iqty)/spl%fsi(mthsurf,iqty)
      ENDDO
      CALL spline_dealloc(spl)

c-----------------------------------------------------------------------
c     transform to configuration space.
c-----------------------------------------------------------------------
      expfac0=EXP(twopi*ifac*theta(1))
      expfac1=1
      xivec0=0
      bvec0=0
      DO itheta=0,mthsurf-1
         expfac=EXP(ifac*(twopi*mlow*theta(itheta)+nn*dphi(itheta)))
         DO ipert=1,mpert
            xivec0(itheta,1)=xivec0(itheta,1)+xipsi(ipert)*expfac
            xivec0(itheta,2)=xivec0(itheta,2)+xitheta(ipert)*expfac
            xivec0(itheta,3)=xivec0(itheta,3)+xizeta(ipert)*expfac
            bvec0(itheta,1)=bvec0(itheta,1)+bpsi(ipert)*expfac
            bvec0(itheta,2)=bvec0(itheta,2)+btheta(ipert)*expfac
            bvec0(itheta,3)=bvec0(itheta,3)+bzeta(ipert)*expfac                    
            expfac=expfac*expfac1
         ENDDO
         expfac1=expfac1*expfac0
      ENDDO

      xivec0(mthsurf,:)=xivec0(0,:)
      bvec0(mthsurf,:)=bvec0(0,:)
c-----------------------------------------------------------------------
c     compute orthogonal components of perturbed magnetic field.
c-----------------------------------------------------------------------
      xivec(:,1)=project(1,1,:)*xivec0(:,1)
      xivec(:,2)
     $     =project(2,1,:)*xivec0(:,1)
     $     +project(2,2,:)*xivec0(:,2)
      xivec(:,3)
     $     =project(3,1,:)*xivec0(:,1)
     $     +project(3,2,:)*xivec0(:,2)
     $     +project(3,3,:)*xivec0(:,3)
      bvec(:,1)=project(1,1,:)*bvec0(:,1)
      bvec(:,2)
     $     =project(2,1,:)*bvec0(:,1)
     $     +project(2,2,:)*bvec0(:,2)
      bvec(:,3)
     $     =project(3,1,:)*bvec0(:,1)
     $     +project(3,2,:)*bvec0(:,2)
     $     +project(3,3,:)*bvec0(:,3)
c-----------------------------------------------------------------------
c     terminate.
c-----------------------------------------------------------------------
      RETURN
      END SUBROUTINE ipeq_ortho